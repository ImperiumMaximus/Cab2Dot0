\newpage
\section{Tools and Test Equipment Required}
This section describes tools and techniques required in order to do all tests described in the previous sections. Moreover all tests require additional testing equipment, thus these sections list them and motivate why they have been done. \\
Here there are the tools needed in order to actually perform the integration testing.

\subsection{Tools}

\subsubsection{Arquillian}
Arquillian is an integration testing tool that facilitates test writing which targets a JEE server. It basically instantiates a EJB container and injects necessary beans in order to perform a requested test, moreover it has the ability to deploy tests directly to a JEE server. Since the back-end of our application is implemented using JEE, this tool is extremely useful and moreover all tests can be run directly from IDE, so this enables all the benefits of testing from an IDE simplifying also debugging.

\subsubsection{JUnit}
The majority of tests described here can be automatized using JUnit (this is true also for unit testing), so this is another important tool that can dramatically speed up the overall testing process. \\ Like Arquillian, JUnit is perfectly integrated in a Java IDE and furthermore the former tool is actually designed to be tightly coupled with the latter. Eventually people who are in charge of testing have a very comfortable and powerful environment to work with, and they can only concentrate on testing instead of being worried about something else. 

\subsubsection{Mockito}
Mockito is a tool that simplifies the creation of mock classes during tests. These are useful when you want to test lines of code already written, but they depend on some other code that is missing because it hasn't been implemented yet. This tool is more useful during unit testing rather than in integration one, but you can reuse mocks created in unit testing phase as stubs for this phase.

\subsubsection{Manual Testing}
Some components of the system are difficult to test using an automated approach, so there are a few cases in which manual testing comes into play. \\ One of the possible examples is GUI testing: it is very complex to test automatically and indeed it is easier to do it using direct interaction between humans who can provide additional feedbacks and possible improvements of the interface in order to enhance the overall end-user experience. 

\subsection{Testing Equipment}

\subsubsection{Testing Environment}
During the Integration Test phase, actual testing will be performed in a specific environment called Testing Environment that is different from Production one. A reason for doing this thing is to have easier and controlled facilities in order to neglect some possible issues that can arise during initial stages of Integration Testing. \\ Of course we should also consider testing in the final environment but this will be done later in more advanced phases, so overall we have a more step-by-step approach. Another benefit coming from this choice is, in general, a speed increase of the overall process. \\ Conversely there are of course possible drawbacks with this method: one of the most important to consider is less power of Testing Environment in respect to the Production one, this might not highlight any issues that eventually will be unnoticed during this phase. These can be hopefully discovered during final testing or in worse cases, after the actual final deployment of the software ready to be distributed.  

\subsubsection{Back-end}
For the back-end, some PCs will be set up with the software and hardware already described in the RASD, furthermore IDEs will be also installed in order to enable testing on these machines. The structure of the overall system will be simple in accordance with what is described in previous section, but it will replicate at least the n-tier structure described in the DD to have a system that closely resembles the production one. \\ The software will be up-to-date in order to have the most recent and stable versions for each of them.

\subsubsection{Front-end}
Since the front-end of the application is designed to be showed from mobile phones, it is necessary they accomplish tasks regarding testing Passenger, Taxi Driver and Sys Admin components that interact with the GUI Logic as well. \\
We think that at least three different models for each Mobile OS should be taken into account: in the RASD we defined the minimum version for each Operating System to run the mobile application, thus we should check the actual compatibility of the app with those versions.\\
Moreover we expect that the application should run flawlessly also with the most up-to-date versions for both Android and iOS, so other smart-phone models that executes these Operating System versions should be used to test the application. \\ At last, even if it is not mandatory, we should check the correct application behavior with version that fall in between this two categories, since a good percentage of users doesn't usually execute on their phone the last available version of a specific Operating System.
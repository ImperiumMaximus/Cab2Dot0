\newpage
\section{Tools and Test Equipment Required}
This section describes tools and techniques required in order to do all tests described in the previous sections. Moreover all tests require additional testing equipment, thus this sections list them and motivates each choice. \\
Here are the tools needed in order to actually perform the integration testing.

\subsection{Tools}

\subsubsection{Arquillian}
Arquillian is an integration testing tools that facilitates the writing on tests which target a JEE server. It basically instantiates a EJB container and injects the necessary beans in order to perform a requested test, moreover it has the ability to deploy tests directly to a JEE server. Since the back-end our application is implemented using JEE, this tool is extremely useful and moreover all tests can be run directly from the IDE, so this enables all the benefits of testing from an IDE and also debugging is easier.

\subsubsection{JUnit}
The majority of the tests described here can be automatized using JUnit (this is true also for unit testing), so this is another important tool that can dramatically speed up the overall testing process. \\ As for Arquillian, JUnit integrates perfectly in a Java IDE and furthermore, the former tool is actually designed to be tightly coupled with the latter, so eventually the people who are in charge of testing have a very comfortable and powerful environment to work with, and they can only concentrate in testing instead of worrying about anything else. 

\subsubsection{Mockito}
Mockito is a tool that simplifies the creation of mock classes during tests. They are useful when you want to test some code that you have just written but it depends on some other code that it is missing because it isn't already implemented. This tool is more useful during unit testing rather than in integration one but still, you can reuse the mocks created in the unit testing phase as stubs for this phase.

\subsubsection{Manual Testing}
Some components of the system are difficult to test using an automated approach so there are a few cases in which manual testing comes into place. \\ One of the possible examples is GUI testing, which is very complex to test automatically and indeed more easy to do using direct interaction of humans, furthermore they can provide additional feedbacks and possible ideas of improvement of the interface in order to enhance the overall end-user experience. 

\subsection{Testing Equipment}

\subsubsection{Testing Environment}
During the Integration Test phase, actual testing will be performed in a specific environment called Testing Environment that is different than Production one. One of the main reasons is to have a simpler and controlled facilities in order neglect some possible issues that can arise during the initials stages of Integration Testing. \\ Of course we should also consider testing in the final environment but this will be done later on in more advanced phases, so overall we have a more step-by-step approach. Another benefit with this approach is, in general, to speed up the overall process. \\ Conversely there are of course possible drawbacks with this method, and one of the most important to consider is that Testing Environment is by construction less powerful than Production one and might not highlight some issues that eventually will be unnoticed during this phase and hopefully can be discovered during final testing or worse after the actual final deployment of the software ready to be used in Production.  

\subsubsection{Back-end}
For the back-end, some PCs will be setup, with the software and hardware already described in the RASD, furthermore, IDEs will be also installed in order to enable testing on these machines, the structure of the overall system will be simple in accordance with what is described in the previous section but will replicate at least the n-tier structure described in the DD so that to have a system that closely resembles the production one. \\ The software will be up-to-date in order to have the most recent and stable versions for each of them.

\subsubsection{Front-end}
Since the front-end of the application is designed to be showed from mobile phones, they are needed to accomplish tasks regarding testing Passenger, Taxi and Sys Admin components, that interact with the GUI Logic as well. \\
Mobile phones are thus other equipment that are also needed with conjunction of PCs as described before, in particular, we think that at least three different models for each Mobile OS should be taken into account: in the RASD we defined the minimum version for each Operating System for running the mobile application, thus we should check the actual compatibility of the app with that versions, moreover we expect that the application should run flawlessly also with the most up-to-date versions for both Android and iOS, so other smart-phones models that executes these Operating Systems' versions should be used to test the application. \\ At last, even if it is not mandatory, we should check the correct behavior with version that fall in between this two categories, since a good percentage of users don't usually executes on their phone the last available version of a specific Operating System.
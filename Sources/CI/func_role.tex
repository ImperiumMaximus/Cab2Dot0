\newpage
\section{Functional Role}
\texttt{DeploymentDescriptorNode} is the base class responsible for handling the XML deployment descriptor, it implements the interface \texttt{XMLNode}.\newline
The XML Deployment Descriptor describes how a web application should be deployed. Each node re-implements this base class and overrides a bunch of methods for handling specific tag names in the XML file. 
As an example, we show here the code of a subclass of \texttt{DeploymentDescriptorNode} which is called \texttt{EjbReferenceNode} which is responsible for handling the \texttt{ejb-reference} XML node tag. We briefly analyze the methods that are overridden. \newline
The first method is \texttt{getDescriptor()} which returns the descriptor of the XML Node being handled and encapsulate all the data regarding the XML node itself such as attributes and sub-tag names. 
\sourcesnippet{69-75}{\texttt{EjbReferenceNode.getDescriptor()} method implementation.}{Code/EjbReferenceNode.java}
Notice that, the method is implemented using the Singleton design pattern.\newline
The second method is called \texttt{getDispatchTable()} which returns a \texttt{Map} associating each tag name to the appropriate function implemented in the \texttt{Descriptor} object returned by \texttt{getDescriptor()}. These functions will be called at runtime using reflection. With this approach one can achieve a high degree of flexibility given that a parent class doesn't need to know anything about the children, they just supply to it how to handle at runtime each sub tag and populate correctly the descriptor, the method \texttt{getDispatchTable()} is implemented as follows:
\sourcesnippet{78-91}{\texttt{EjbReferenceNode.getDispatchTable()} method implementation.}{Code/EjbReferenceNode.java}
At last, the method \texttt{writeDescriptor()} is responsible to perform the actual write of the DOM tree node taking the values from the \texttt{Descriptor} object whose attributes were populated previously. Eventually the DOM node is returned so that it will be inserted to the overall tree, the function is implemented by this code:
\sourcesnippet{93-127}{\texttt{EjbReferenceNode.writeDescriptor()} method implementation.}{Code/EjbReferenceNode.java}
As said before, a subclass is responsible for writing the DOM representation of the tag being handled, each tag is composed by attributes and possibly sub-tags. Sub-tags can be managed by the same class or delegated to other subclasses which are registered to the parent class. \newline This implies that all the classes inheriting from \texttt{DeploymentDescriptorNode} are shaped like a tree with one root \texttt{DeploymentDescriptorNode} and they are arranged according to the DTD. \newline The SAX parser is responsible of interacting with the correct subclass depending on which tag is encountered while parsing the XML file by calling the method\newline\texttt{XMLNode.getHandlerFor(element)}. The parameter \texttt{element} is an instance of the class \texttt{XMLElement}, which contains simple attributes for encapsulating the tag name and the (possible) XML namespace. The function returns an object whose static type is \texttt{XMLNode} but the runtime type is one of the possible subclasses of \newline \texttt{DeploymentDescriptorNode} which will handle the tag as described previously. \newline
Eventually the full DOM tree of the XML is created in memory which will be manipulated later by Glassfish in order to deploy the web application.
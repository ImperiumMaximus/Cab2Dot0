\newpage
\section{Functional Role}
\texttt{DeploymentDescriptorNode} is a base class responsible for handling a XML deployment descriptor, it implements the interface \texttt{XMLNode}.\newline
The XML Deployment Descriptor describes how a web application should be deployed. Each node reimplements this base class and overrides a bunch of methods for handling specific tag names in a XML file. 
For instance, we show here the code of a subclass of \texttt{DeploymentDescriptorNode} which is called \texttt{EjbReferenceNode}, it is responsible for handling \texttt{ejb-reference} XML node tags. We briefly analyze methods that are overridden. \newline
The first method is \texttt{getDescriptor()} which returns a descriptor of a XML Node being handled and encapsulates data regarding its XML node such as attributes and sub-tag names. 
\sourcesnippet{69-75}{\texttt{EjbReferenceNode.getDescriptor()} method implementation.}{Code/EjbReferenceNode.java}
Notice that, this method is implemented using Singleton design pattern.\newline
Second method is called \texttt{getDispatchTable()} which returns a \texttt{Map} associating each tag name to an appropriate function implemented in a \texttt{Descriptor} object returned by \texttt{getDescriptor()}. These functions will be called at runtime using reflection. With this approach, it is possible to achieve a high degree of flexibility since a parent class doesn't need to know anything about its children, they just supply to it how to handle at runtime each subtag and populate correctly its descriptor. \texttt{getDispatchTable()} method is implemented as follows:
\sourcesnippet{78-91}{\texttt{EjbReferenceNode.getDispatchTable()} method implementation.}{Code/EjbReferenceNode.java}
At last, \texttt{writeDescriptor()} method is responsible to perform the actual construction of a DOM tree node taking values from a \texttt{Descriptor} object whose attributes were populated previously. Eventually the DOM node is returned so that it will be inserted in the overall tree, this function is implemented by this code:
\sourcesnippet{93-127}{\texttt{EjbReferenceNode.writeDescriptor()} method implementation.}{Code/EjbReferenceNode.java}
As explained before, a subclass is responsible for writing a DOM representation of a handled tag, each tag is composed by attributes and possibly subtags. These last ones can be managed by a same class or delegated to other subclasses which are registered to the parent class. \newline This implies that all classes inheriting from \texttt{DeploymentDescriptorNode} are shaped like a tree with one root \texttt{DeploymentDescriptorNode} and they are arranged according to DTD. \newline SAX parser is responsible of interacting with correct subclasses depending on which tag is encountered while parsing a XML file by calling the method\newline\texttt{XMLNode.getHandlerFor(element)}. \texttt{element} parameter is an instance of \texttt{XMLElement} class which contains simple attributes to encapsulate tag names and (possible) XML namespaces. This function returns an object whose static type is \texttt{XMLNode} but its runtime type is one of possible subclasses of \newline \texttt{DeploymentDescriptorNode} which will handle a tag as described previously. \newline
Eventually a full DOM tree of the XML is created in memory which will be manipulated later by Glassfish in order to deploy the web application. \newline
This information has been gathered directly by the documentation of the source code written in Javadoc and it is placed within the code itself. Documentation is also publicly available from Glassfish official site. Another important source of information comes from Oracle, which points out in its documentation, what a XML Deployment Descriptor is and its role in the whole JEE ecosystem.
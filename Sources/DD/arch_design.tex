\section{Architectural Design}
\subsection{Overview}
\label{sec:overview}
The system is constituted by a three-tier architecture, in fact it's divided into GUI, application programs and database. The first one isn't only on users' devices, since the interface stays on users' smartphones and browsers, but the logic part is located on server side. On another server lays the application part where the system manages interactions between components and elaborates inputs coming from GUI. Database storage stays on a separated server from the logic one, it contains information about taxi drivers and their cabs, in addition to passenger personal details.  
\subsection{High level components and their interaction}
\label{sec:high-level}
The following diagram shows the composition of the system in terms of high level components. \newline
In the next section these components are explained and further analyzed to describe the overall system.
\begin{figure}[H]
	\centering
	\resizebox{6in}
	{!}{\input{HighLevelComponentDiagram.pdf_tex}}
	\caption{High level components diagram}
\end{figure}
As one can see in the diagram, the system is composed in three distinct levels:
\begin{itemize}
	\item GUI Logic
	\item Access Control and Ride Manager
	\item Database
\end{itemize}
These components can be easily mapped in the MVC architectural style (as later described in \nameref{sec:arch-styles-patterns} section).
Each component is also mapped in a specified tier among the server architecture as briefly described in the \nameref{sec:overview} section and further explained in the \nameref{sec:arch-styles-patterns} section.
The remaining component models all possible actors, in fact it represents physical elements (a smartphone or a computer with an appropriate software installed on them) that actually interact with the system. \newline
The diagram clearly shows that there is a single macro-component that exposes a set of functionalities and methods an actor can use. This macro-component is the only entry point available to all the actors, this coiche has been made to preserve a simple architecture and also to increase the cohesion and reusability of the component itself. \newline
This component is actually composed of a bunch of sub-components as described in the next section \nameref{sec:component-view}, each sub-component carries out specific functionalities for each actor defined in the RASD.
\subsection{Component View}
\label{sec:component-view}
\begin{figure}[H]
	\centering
	\resizebox{6in}
	{!}{\input{ComponentDiagramStripped.pdf_tex}}
\end{figure}
appunti: explain queue manager, how the ride manager and taxi driver ui logic interact with it, explain why a maps services component and an external db for cars and driver are needed.
\paragraph{Actors}
It's possible to see from this diagram a generic ``Actor'' component is now split in three different components, one for each actor, the main reason for this decision is that each actor accesses and uses a specific interface supplied in one of the three sub-components in the GUI Logic component. Methods that comprise such interfaces are described in the \nameref{sec:arch-styles-patterns} section.
\paragraph{GUI Logic}
The GUI Logic component hosts the interface logic suitable for using both a web browser and a mobile application, this component has the main role of collecting all requests from external devices of all actors, and then forward them to the right back-end component.
\paragraph{Access Control}
The Access Control component manages the authentication users, and their permissions, ensuring that only registered users can use certain functions of the system. \newline Since these functionalities are similar to all actors, this component is unique, and the methods in its external interface are designed so that the component is aware of what type of actor is performing a specific action, the advantage of using such design is to increase the flexibility, and the reusability without sacrificing the simplicity of the overall system.
\paragraph{Ride Manager}
The Ride Manager component in charge of managing all the rides instances that are being served. This component creates, keeps track, terminates, each ride managed by the system. Each instance can be seen as a FSA, and the methods in the external interface in the component implement a state transition in the automaton, this is further described in the \nameref{sec:arch-styles-patterns} section. \newline
This component manages both the requests and the reservations, in fact a reservation can be seen as a ``delayed'' request, thus we a little addition in the algorithms we can achieve both functionalities with little effort maximizing the reusability of such component.
\paragraph{Queue Manager}
This component manages all the queues belonging to the city map, one queue for each zone. The component strictly cooperate with the Ride Manager, but its external interface is generic enough to abstract the actual implementation of the policies for managing the queues. This allows the best flexibility and decoupling between this two components, whereas the architecture still remain simple and easy to understand, one can realize different implementations of the Queue Manager for instance a generic one for most of the zones, and a specific one for certain zones, for different reasons, for instance traffic load higher than normal, or a higher or a lesser probability of receive a request for a client in a specific zone. This policies can be considered during the implementation phase. \newline
The component also manages the working state of the Taxi drivers, allow them to change between unavailable and available state then in turn removing or inserting them in the appropriate queue according to their location in the map (further described in the \nameref{sec:algo} section)
\paragraph{myTaxiService Database}
\paragraph{External Maps Services}
\paragraph{External Cars and Drivers database}
\subsection{Deployment View}
\begin{figure}[H]
	\centering
	\resizebox{6in}
	{!}{\input{DeploymentDiagram.pdf_tex}}
\end{figure}
appunti: for taxi driver and passengers use already present sdk frameworks to implement apps, JEE, mysql, JDBC, SOAP
\subsection{Runtime View}
\subsubsection{Passenger Login}
\begin{figure}[H]
	\small
	\centering
	\resizebox{6in}
	{!}{\input{LoginRuntime.pdf_tex}}
	\end{figure}
\subsubsection{Passenger's Request}
\begin{figure}[H]
	\small
	\centering
	\resizebox{6in}
	{!}{\input{MakeRequest.pdf_tex}}
\end{figure}
\subsubsection{Taxi Driver Registration}
\begin{figure}[H]
	\small
	\centering
	\resizebox{6in}
	{!}{\input{DriverRegistration.pdf_tex}}
\end{figure}
\subsubsection{Taxi Driver Availability status change}
\begin{figure}[H]
	\small
	\centering
	\resizebox{6in}
	{!}{\input{DriverStatusChange.pdf_tex}}
\end{figure}
\subsection{Component Interfaces}
In this section all interfaces that connect each component in the component view are explained and analyzed.
\subsubsection{Passenger UI Logic Interface}
This interface provides the entry point to the system for passengers. \newline
The following is a list of the methods provided by this interface, they are all pretty self-explanatory:
\begin{itemize}
	\item \texttt{showHome()}
	\item \texttt{showLogin()}
	\item \texttt{showSignUp()}
	\item \texttt{showRequestPage()}
	\item \texttt{showReservationPage()}
	\item \texttt{showRequestInformation()}
	\item \texttt{submitLoginCredentials()}
	\item \texttt{submitRegistrationCred()}
	\item \texttt{submitRequestData()}
	\item \texttt{submitReservationData()}
\end{itemize}
The interface is comprised as a series of methods that passengers can invoke. Each \texttt{show*()} method maps to a specific web page or screen in the mobile application, the actual invocation takes place when a passenger loads in his/her browser or in one screen of the application. Each page or screen has some sort of navigation methods so that it can call other \texttt{show*()} methods present in this interface. \newline
The \texttt{submit*()} methods are called when a passenger wants to send data to system, for instance when he/she has just completed the filling of a form, these methods validate inputs and forward the request of the appropriate component in the system back-end, eventually they show an informative page or a screen that notify the user whether the operation is completed or not, and in the latter case why. 
\subsubsection{Taxi Driver UI Logic Interface}
This interface provides the entry point to the system for the taxi driver.
The list of the methods is the following:
\begin{itemize}
	\item \texttt{showLogin()}
	\item \texttt{submitLoginCredentials()}
	\item \texttt{submitResponseForIncomingRequest()}
	\item \texttt{submitNewWorkingStatus()}
	\item \texttt{showNewIncomingRequest()}
\end{itemize}
Meaning and functional aspects of these methods are more or less similar to what has been explained in the previous section, one point to note is that this time these methods are invoked only by the mobile application installed in the taxi driver's smartphone, so there is no web interface available to this specific actor.
\subsubsection{System Administrator UI Logic Interface}
This interface provides the entry point to the system for the administrator. \newline
List of methods:
\begin{itemize}
	\item \texttt{showLogin()}
	\item \texttt{showMainMenu()}
	\item \texttt{showAddNewDriver()}
	\item \texttt{showRemoveDriver()}
	\item \texttt{showModifyDriver()}
	\item \texttt{submitLoginCredentials()}
	\item \texttt{submitDriverInformation()}
	\item \texttt{submitDeleteRequest()}
\end{itemize}
It can notice that pattern names for these methods are the same of previous sections.
\subsubsection{Access Control Interface}
This interface supplies all the methods that enforce authentication and right management in the system. \newline
List of methods:
\begin{itemize}
	\item \texttt{login()}
	\item \texttt{logout()}
	\item \texttt{passengerSignUp()}
	\item \texttt{taxiDriverSignUp()}
	\item \texttt{passengerDelete()}
	\item \texttt{taxiDriverDelete()}
	\item \texttt{taxiDriverModifyCredentials()}
	\item \texttt{modifyPassengerCredentials()}
\end{itemize}
\subsubsection{Ride Manager Interface}
This interface contains methods to create and to manage a single ride instance, both requests and reservations. \newline
List of methods:
\begin{itemize}
	\item \texttt{createRequest()}
	\item \texttt{acceptRequest()}
	\item \texttt{declineRequest()}
	\item \texttt{createReservation()}
\end{itemize}
\subsubsection{Queue Manager Interface}
This interface comprises methods that manage the availability of taxis and supplies functions to add or to remove taxis. \newline
List of methods:
\begin{itemize}
	\item \texttt{addTaxi()}
	\item \texttt{removeTaxi()}
	\item \texttt{assignTaxi()}
	\item \texttt{changeTaxiStatus()}
\end{itemize}
\subsubsection{Databases interface}
This interface is not directly implemented in the system-to-be, instead an existing third party library (JDBC) is used which supplies its own set of interfaces to the system that can manipulate the database.
\subsubsection{Maps API}
As with the previous section, also this interface is exposed by a third party component so that it exposes a series of methods that are suitable in the system-to-be.
\subsection{Selected architectural styles and patterns}
\label{sec:arch-styles-patterns}
The following section lists and describes the architectural styles that represent feasible choices during the development and the deployment phases. All the requirements specified in the RASD are taken into account, and also the design choices described in this document. 
\subsection{Architectural styles}
\paragraph{3-tier architecture}
As implicitly explained in the \nameref{sec:overview} section, this is perhaps the most important style, also because all the components diagram and also the deployment view is modeled against this architecture, from the latter diagram we can infer that the tiers map in this way:
\begin{itemize}
	\item GUI Logic to Presentation tier 
	\item Ride Manager, Access Control, Queue Manager, Maps to Logic tier
	\item Databases to the Data tier
\end{itemize}
The main advantages of using this style is that it achieves a high level of modularity and flexibility of the overall system, also each tier can be designed and dimensioned based on the computational and power needed for it, moreover, as described in the non-functional requirements in the RASD each component is isolated with the respect to the others so that increases the security of each of them and also the overall system. One possible drawbacks is the increased complexity of the interfaces that need to be designed so that each tier can communicate each other, also each user interaction corresponds to many API methods calls within the system which in turn trigger some further processing of the data exchanged between the tiers, this can result in some loss of performance and response times, but this is mitigated by the fact that our interfaces are simple enough and also require little to none processing of the data when passing it from one tier to another.
\paragraph{SOA}
This style is used throughout the system both for the services that itself offers to the ``Actors'' and for the third party services that the system use to achieve its goals. Thus the system acts both as a service provider and as a service requester. \newline
The services provided are of course the ones that derive from the goals already described in the RASD, thus requesting and reserving taxi, plus some accessory functionalities that we also described in the RASD (login, signup, etc.).\newline
The services requested are the Maps Service and the external Cars and Drivers database that are needed in order to actually implement the services offered by this system, both are already been defined, implemented and documented so this document doesn't specify them in detail but we assume that can be easily integrated in the system using the already existing documentation. 
\paragraph{Client-Server architecture}
This is tightly coupled with both the 3-tier and SOA styles described previously, and this is one of the most used and common style used.
\subsection{Design patterns}
\paragraph{MVC}
\paragraph{Publisher-subscriber}
\paragraph{Fa\c{c}ade}
\paragraph{Singleton}
\paragraph{State pattern}
\subsection{Other design decisions}